# V8 Javascript Engine ðŸš€

V8 is Googleâ€™s open source high-performance **JavaScript** and **WebAssembly** engine, written in C++. It is used in Chrome and in **Node.js**, among others. It implements **ECMAScript** and WebAssembly, and runs on **Windows 7** or later, **macOS 10.12+**, and Linux systems that use **x64, IA-32, ARM, or MIPS processors**. V8 can run standalone, or can be embedded into any C++ application.

---

## Javascript Runtime Environment

![demo13](/assets/demo19.webp)

The JavaScript runtime environment is the environment in which JavaScript code is executed. It consists of the combination of the browser (in the case of client-side JavaScript) or the server (in the case of server-side JavaScript, like Node.js) and the JavaScript engine.

Here are key components of the JavaScript runtime environment:

**JavaScript Engine:** The core component responsible for interpreting and executing JavaScript code. Examples include **V8 (used in Chrome and Node.js), SpiderMonkey (used in Firefox), and JavaScriptCore (used in Safari).**

**Call Stack:** The call stack is a data structure that stores information about the currently executing functions or methods. It keeps track of the flow of control in the program.

**Heap:** The heap is the memory space where dynamically allocated objects are stored. This is where objects, arrays, and other data structures are created and managed.

**Web APIs (Browser Environment):** In a browser environment, Web APIs provide additional functionality beyond the core JavaScript language. Examples include the DOM (Document Object Model), XMLHttpRequest, Fetch API, and more.

**Event Loop:** The event loop is a crucial part of the runtime environment, especially in asynchronous JavaScript. It manages the execution of callbacks and events, ensuring non-blocking behavior.

**Callback Queue:** The callback queue holds callbacks and events that are ready to be executed. The event loop checks the queue and processes callbacks when the call stack is empty.

**Concurrency Model:** JavaScript follows a single-threaded, non-blocking concurrency model. This means that it has one main thread of execution but can handle asynchronous operations efficiently, thanks to features like callbacks, Promises, and async/await.

---

## Types of Javascript Engines

Script code. Various browsers and environments use different JavaScript engines. Here are some of the prominent ones:

* V8 (Google Chrome, Node.js)

* SpiderMonkey (Mozilla Firefox)

* JavaScriptCore (WebKit, Safari)

* Chakra (Microsoft Edge - Legacy)

* ChakraCore (Node.js, Windows apps)

* Rhino (Mozilla Rhino)

* JerryScript (IoT devices)

* Duktape (Embeddable)

---

## JS Engine Architecture

![demo17](/assets/demo17.png)

### Things happening behind the scenes

1. **Parsing**
2. **Compilation**
3. **Execution**
4. Memory Management
5. Optimization
6. Error Handling
7. ECMAScript Compliance
8. Platform Integration

---

## 1. Parsing

The engine starts by parsing the JavaScript source code. During this process, the code is analyzed and converted into an internal representation known as **Abstract Syntax Tree (AST).** which is generated by **Syntax Parser.**

```js
const course = "Namaste Javascript";

function greet() {
  console.log("Namaste");
}
```

**Tokens**

![demo14](/assets/demo14.png)

**AST Tree**

![demo15](/assets/demo15.png)

```js
const course = "Namaste Javascript";
```

**AST in JSon Format**

```json
{
  "type": "Program",
  "start": 0,
  "end": 37,
  "body": [
    {
      "type": "VariableDeclaration",
      "start": 0,
      "end": 36,
      "declarations": [
        {
          "type": "VariableDeclarator",
          "start": 6,
          "end": 35,
          "id": {
            "type": "Identifier",
            "start": 6,
            "end": 12,
            "name": "course"
          },
          "init": {
            "type": "Literal",
            "start": 15,
            "end": 35,
            "value": "Namaste Javascript",
            "raw": "\"Namaste Javascript\""
          }
        }
      ],
      "kind": "const"
    }
  ],
  "sourceType": "module"
}
```

--- 

## 2. Compilation:

The engine may employ various techniques, including **Just-In-Time (JIT) compilation or Ahead-of-Time (AOT) compilation**, to translate the parsed code into machine code that the computer's hardware can execute.

#### JIT Compilation

JIT (Just-In-Time) compilation is a technique used by JavaScript engines and some other programming language runtimes to improve the performance of code execution. Instead of interpreting the source code directly, JIT compilation involves dynamically translating the code into machine code at runtime just before it is executed. This process is designed to combine the advantages of both interpreted and compiled approaches.

--- 

* Initially, the JavaScript engine reads and interprets the source code directly. This interpretation involves parsing the code and generating an intermediate representation, such as an Abstract Syntax Tree (AST) or bytecode.
* Many modern JavaScript engines, **including V8 (used in Google Chrome and Node.js) and SpiderMonkey (used in Mozilla Firefox), employ a Just-In-Time (JIT) compilation approach.**
* Instead of interpreting the entire source code, the engine selectively compiles specific portions of the code into machine code just before they are about to be executed. This compilation occurs on-the-fly, or "just in time."
* The compiled machine code is stored in memory and executed by the computer's hardware. This machine code is more optimized for performance than the original interpreted code.
* Once the AST is constructed, the engine generates an intermediate representation (IR) or **bytecode**. Bytecode is a lower-level, platform-independent representation of the code. It's not machine code but a set of instructions that can be efficiently executed by a virtual machine.

![demo16](/assets/demo16.png)

---

## 3. Execution: 

In JavaScript, the execution of code goes through several phases after the **bytecode** has been generated. These phases collectively form the **execution context**, and understanding them is crucial for comprehending how JavaScript code is run. Here are the primary steps in the execution phase.

* Creation of Execution Context
* Variable and Function Declarations
* Lexical Environment and Scope Chain
* Hoisting
* Execution of Code
* Execution Stack (Call Stack)
* Scope Chain and Lexical Scoping
* Closure
* Asynchronous Operations
* Garbage Collection
